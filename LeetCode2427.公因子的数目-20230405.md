## LeetCode刷题2427.公因子的数目

![image-20230405194722350](https://blog-1304436410.cos.ap-beijing.myqcloud.com/leetcode/202304051947412.png)



### 方法1：枚举

#### **算法思想**

因为$a$和$b$的公因子一定不会超过$a$和$b$，所以只要遍历$[1,min(a,b)]$中所有元素，枚举出所有公因数$x$，用$ans$记录$x$的数量



```C++
class Solution {
public:
    int commonFactors(int a, int b) {
        int ans = 0;//记录公因子的数目
        for(int x = 1; x <= min(a,b); ++x)
        {
            if(a % x == 0 && b % x == 0)
            {
                ++ans;
            }
        }
        return ans;
    }
};
```

#### **复杂度分析**

**时间复杂度：**$O\left(min \left \{ a,b \right \}\right)$

**空间复杂度：**$O(1)$



### 方法2：枚举优化

#### **算法思想**

我们可以先算出 $a$和 $b$ 的最大公约数 $g$，然后枚举最大公约数 $g$ 的所有公因子，也就是对$[1,g]$中所有整数依次枚举。

```C++
class Solution {
public:
    int commonFactors(int a, int b) {
        int ans = 0;//记录公因子的数目
        int g = gcd(a,b);//g为a,b之间的最大公因子
        for(int x = 1; x*x <= g; ++x)//枚举[1,g]中的公因子
        {
            if(g % x == 0)
            {
                ++ans;
                if(x * x != g)
                {//该数如果恰好为平方根则只需加上面一次 eg.12 4的最大公约数为4,则当2为4的公约数时，此if不执行，就不需要额外+1了
                    ++ans;
                }
            }
        }
        return ans;
    }
};
```

##### 补充1：优化枚举[1,g]之间的公因子

对于 $[1,g]$ 中的整数依次进行枚举，时间复杂度为 $O(g)$。我们也可以进行一些优化，因子一定是成对出现的：如果$x$ 是 $g$的因子，那么 $\frac{g}{x}$ 一定也是 $g$的因子。因此，我们可以仅对$[1, \lfloor g \rfloor]$中的整数依此进行枚举，

如果枚举到 $x$ 是 $g$的因子，并且 $x \ne \frac{g}{x}$ (即$x^2 \ne g$)，那么答案额外+1。




##### **补充2：求最大公因子(gcd)**

数学方法：辗转相除法(欧几里德算法)

辗转相除法， 又名欧几里德算法（Euclidean algorithm），是求最大公约数的一种方法。它的具体做法是：

用较大数除以较小数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。

~~∵ 319÷377=0（余319）~~
~~∴（319，377）=（377，319）~~

例如，求（319，377）：

∵ 377÷319=1（余58）
∴（377，319）=（319，58）；
∵ 319÷58=5（余29）
∴ （319，58）=（58，29）；
∵ 58÷29=2（余0）
∴ （58，29）= 29；

Conclusion: gcd（319，377）= 29。
用辗转相除法求几个数的最大公约数，可以先求出其中任意两个数的最大公约数，再求这个最大公约数与第三个数的最大公约数，依次求下去，直到最后一个数为止。最后所得的那个最大公约数，就是所有这些数的最大公约数。

##### 具体实现：[【C++】gcd函数的写法](https://blog.csdn.net/Ljnoit/article/details/99319849)

#### **复杂度分析**

**时间复杂度：**$O \left (\sqrt {min \left \{ a,b \right \}}\right )$需要注意的是，求解 $a $和 $b$ 最大公约数需要 $O(log\ n)$ 的时间，但其渐进意义下小于 $O( n )$，可以省略。

**空间复杂度：**$O(1)$